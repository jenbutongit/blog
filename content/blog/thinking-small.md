---
title: "Thinking Small"
date: 2020-11-21T18:10:32+01:00
slug: ""
description: "How do you deliver the barest bones possible?"
keywords: []
draft: true
tags: []
math: false
toc: false
---

One of the difficulties I've noticed when bringing in apprentice and graduate developers in to a new delivery team is that they often find it difficult to think small. By which I mean, if they're given a task to complete they'll either end up in analysis paralysis, thinking of all the things they _could_ do. Or spend the entire sprint on delivering to every possible variation.

This is fine, they're learning, and is entirely on me to guide them and help them improve.

I think there are a few causes for this. One is for a new developer to want to prove themselves. To show they've thought of everything. I can totally understand and appreciate it. There is no wrong answer, but it's an optimisation problem, or YAGNI. It's one of those situations where less is more, and it's really difficult to measure success on those terms.

The other cause I think is that software engineering courses rarely, if ever, focus on user need. There's rarely any real world use cases to work to in an academic setting. Maybe the user is actually a lecturer who may not really understand the scenario they're supposed to be representing beyond metaphors. Similarly to above you also run in to difficulties of measuring success beyond delivering a lot of features.

But the cause is only academic and an interesting artefact.

## How to think lazily

There's a [quote attributed to Bill Gates](https://www.goodreads.com/quotes/568877-i-choose-a-lazy-person-to-do-a-hard-job) that says

<!--alex ignore easy-->
> “I choose a lazy person to do a hard job. Because a lazy person will find an easy way to do it.”

It can be mean, and seems unfair, but my first approach is always "Taking this task strictly by the words provided, no extra definitions or external input, how can I achieve this with the minimal amount of effort and lines of code." Or another way "How quickly can I get this off my task list and move on to something else".

You do however have to walk a tightrope between being lazy and being _seen_ as being lazy. Solve the problem quickly, but validate your workings with someone else, be it a senior developer, or even a user. Perhaps you don't have a definition of done, or maybe there is one and it's not specific enough. Perhaps that needs improving.

## Hackathons

Far be it for me to tell developers that they must spend both their professional and personal time coding. I don't subscribe to that rhetoric, it's privileged and exclusionary.

But one thing that can focus on solving small problems quickly is hackathons. These can be done as a part of work, and I think they're good practice to do so for when the proverbial hits the fan and you need to learn to get systems back working fast.

They allow you to ask yourself, if you have 8 hours, how are you going to solve this problem. It can also be an opportunity to put more junior members of the team in charge of the team. They gain experience and can start to empathise with senior team members.

Boiling it all down, what it means is not to think about how to maximise your time on a task, but how to maximise your time doing something else. Even if it is the latest Call of Duty.
